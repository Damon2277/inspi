#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

console.log('üîß ‰øÆÂ§çÊúÄÁªàÁöÑTypeScriptÈîôËØØ...\n');

/**
 * Fix 1: Á°Æ‰øùuseAuth hookÊ≠£Á°ÆÂØºÂá∫ÊâÄÊúâÁ±ªÂûã
 */
function ensureUseAuthExports() {
  console.log('üì¶ Á°Æ‰øùuseAuthÂØºÂá∫ÊâÄÊúâÂøÖÈúÄÁöÑÁ±ªÂûã...');
  
  const useAuthPath = path.join(__dirname, '../src/shared/hooks/useAuth.ts');
  
  // Â¶ÇÊûúÊñá‰ª∂‰∏çÂ≠òÂú®Ôºå‰ªéAuthContext.tsxÂ§çÂà∂ÂÜÖÂÆπ
  if (!fs.existsSync(useAuthPath)) {
    // ÂàõÂª∫ÁõÆÂΩï
    const hookDir = path.join(__dirname, '../src/shared/hooks');
    if (!fs.existsSync(hookDir)) {
      fs.mkdirSync(hookDir, { recursive: true });
    }
    
    const useAuthContent = `import { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';

export interface User {
  _id?: string;
  id: string;
  email: string;
  name?: string;
  role: 'user' | 'admin' | 'moderator';
  avatar?: string;
  subscription?: {
    plan: 'free' | 'pro' | 'super';
    tier?: 'free' | 'basic' | 'premium' | 'enterprise';
    startDate: Date;
    endDate?: Date;
    isActive: boolean;
  };
  emailVerified?: boolean;
  createdAt?: Date;
  updatedAt?: Date;
}

export interface AuthState {
  isAuthenticated: boolean;
  isLoading: boolean;
  user: User | null;
  token: string | null;
}

export interface LoginCredentials {
  email: string;
  password: string;
  rememberMe?: boolean;
}

export interface RegisterData {
  email: string;
  password: string;
  name?: string;
  confirmPassword?: string;
}

export interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  register: (data: RegisterData) => Promise<void>;
  logout: () => Promise<void>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  checkAuth: () => Promise<void>;
}

export type UseAuthReturn = AuthContextType;

export function useAuth(): UseAuthReturn {
  const router = useRouter();
  const [authState, setAuthState] = useState<AuthState>({
    isAuthenticated: false,
    isLoading: true,
    user: null,
    token: null,
  });

  const login = useCallback(async (credentials: LoginCredentials) => {
    setAuthState(prev => ({ ...prev, isLoading: true }));
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials),
      });

      if (!response.ok) throw new Error('Login failed');

      const data = await response.json();
      
      // Á°Æ‰øùuserÊúâidÂ≠óÊÆµ
      if (data.user && !data.user.id && data.user._id) {
        data.user.id = data.user._id;
      }
      
      setAuthState({
        isAuthenticated: true,
        isLoading: false,
        user: data.user,
        token: data.token,
      });

      if (credentials.rememberMe && data.token) {
        localStorage.setItem('token', data.token);
      } else {
        sessionStorage.setItem('token', data.token);
      }
    } catch (error) {
      setAuthState(prev => ({ ...prev, isLoading: false }));
      throw error;
    }
  }, []);

  const register = useCallback(async (data: RegisterData) => {
    setAuthState(prev => ({ ...prev, isLoading: true }));
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error('Registration failed');

      const result = await response.json();
      
      // Á°Æ‰øùuserÊúâidÂ≠óÊÆµ
      if (result.user && !result.user.id && result.user._id) {
        result.user.id = result.user._id;
      }
      
      setAuthState({
        isAuthenticated: true,
        isLoading: false,
        user: result.user,
        token: result.token,
      });

      localStorage.setItem('token', result.token);
    } catch (error) {
      setAuthState(prev => ({ ...prev, isLoading: false }));
      throw error;
    }
  }, []);

  const logout = useCallback(async () => {
    setAuthState(prev => ({ ...prev, isLoading: true }));
    try {
      localStorage.removeItem('token');
      sessionStorage.removeItem('token');
      
      setAuthState({
        isAuthenticated: false,
        isLoading: false,
        user: null,
        token: null,
      });

      router.push('/');
    } catch (error) {
      setAuthState(prev => ({ ...prev, isLoading: false }));
      throw error;
    }
  }, [router]);

  const updateProfile = useCallback(async (data: Partial<User>) => {
    setAuthState(prev => ({ ...prev, isLoading: true }));
    try {
      const token = localStorage.getItem('token') || sessionStorage.getItem('token');
      
      const response = await fetch('/api/auth/profile', {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': \`Bearer \${token}\`,
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error('Update failed');

      const updatedUser = await response.json();
      
      // Á°Æ‰øùuserÊúâidÂ≠óÊÆµ
      if (updatedUser && !updatedUser.id && updatedUser._id) {
        updatedUser.id = updatedUser._id;
      }
      
      setAuthState(prev => ({
        ...prev,
        isLoading: false,
        user: updatedUser,
      }));
    } catch (error) {
      setAuthState(prev => ({ ...prev, isLoading: false }));
      throw error;
    }
  }, []);

  const checkAuth = useCallback(async () => {
    const token = localStorage.getItem('token') || sessionStorage.getItem('token');
    
    if (!token) {
      setAuthState({
        isAuthenticated: false,
        isLoading: false,
        user: null,
        token: null,
      });
      return;
    }

    try {
      const response = await fetch('/api/auth/profile', {
        headers: {
          'Authorization': \`Bearer \${token}\`,
        },
      });

      if (response.ok) {
        const user = await response.json();
        
        // Á°Æ‰øùuserÊúâidÂ≠óÊÆµ
        if (user && !user.id && user._id) {
          user.id = user._id;
        }
        
        setAuthState({
          isAuthenticated: true,
          isLoading: false,
          user,
          token,
        });
      } else {
        throw new Error('Invalid token');
      }
    } catch {
      localStorage.removeItem('token');
      sessionStorage.removeItem('token');
      setAuthState({
        isAuthenticated: false,
        isLoading: false,
        user: null,
        token: null,
      });
    }
  }, []);

  useEffect(() => {
    checkAuth();
  }, [checkAuth]);

  return {
    user: authState.user,
    isAuthenticated: authState.isAuthenticated,
    isLoading: authState.isLoading,
    login,
    register,
    logout,
    updateProfile,
    checkAuth,
  };
}

// Êèê‰æõAuthProviderÁªÑ‰ª∂
import React, { createContext, useContext, ReactNode } from 'react';

const AuthContext = createContext<UseAuthReturn | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const auth = useAuth();
  return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;
}

export function useAuthContext() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuthContext must be used within AuthProvider');
  }
  return context;
}

export default useAuth;
`;
    
    fs.writeFileSync(useAuthPath, useAuthContent);
    console.log('‚úÖ ÂàõÂª∫‰∫ÜÂÆåÊï¥ÁöÑ useAuth.ts Êñá‰ª∂');
  }
}

/**
 * Fix 2: ‰øÆÂ§çAuthContextÂØºÂÖ•
 */
function fixAuthContextImports() {
  console.log('üì¶ ‰øÆÂ§çAuthContextÂØºÂÖ•...');
  
  const authContextPath = path.join(__dirname, '../src/contexts/AuthContext.tsx');
  if (fs.existsSync(authContextPath)) {
    let content = fs.readFileSync(authContextPath, 'utf8');
    
    // ‰øÆÂ§çÂØºÂÖ•ËØ≠Âè•Âíå‰ΩøÁî®
    content = content.replace(
      /import { useAuth as useAuthHook.*?} from '@\/shared\/hooks\/useAuth';/,
      "import { useAuth, UseAuthReturn, User, AuthState, LoginCredentials,
        RegisterData, AuthContextType } from '@/shared/hooks/useAuth';"
    );
    
    // ‰øÆÂ§çuseAuthË∞ÉÁî®
    content = content.replace(/const authData = useAuthHook\(\);/, 'const authData = useAuth();');
    content = content.replace(/const authData = useAuth\(\);/, 'const authData = useAuth();');
    
    fs.writeFileSync(authContextPath, content);
    console.log('‚úÖ ‰øÆÂ§ç‰∫Ü AuthContext.tsx ÂØºÂÖ•');
  }
}

/**
 * Fix 3: ‰øÆÂ§çsetStateÂõûË∞ÉÁ±ªÂûã
 */
function fixSetStateCallbacks() {
  console.log('üì¶ ‰øÆÂ§çsetStateÂõûË∞ÉÁ±ªÂûã...');
  
  // ‰øÆÂ§çLoginForm
  const loginFormPath = path.join(__dirname, '../src/components/auth/LoginForm.tsx');
  if (fs.existsSync(loginFormPath)) {
    let content = fs.readFileSync(loginFormPath, 'utf8');
    
    // ‰øÆÂ§çsetStateÂèÇÊï∞Á±ªÂûã
    content = content.replace(
      /setFormData\(\(prev.*?\) =>/g,
      'setFormData(prev =>'
    );
    
    content = content.replace(
      /setErrors\(\(prev.*?\) =>/g,
      'setErrors(prev =>'
    );
    
    content = content.replace(
      /setShowPassword\(\(prev.*?\) =>/g,
      'setShowPassword(prev =>'
    );
    
    // ‰øÆÂ§çboolean toggle
    content = content.replace(
      /setShowPassword\(prev => !prev\)/g,
      'setShowPassword(!showPassword)'
    );
    
    fs.writeFileSync(loginFormPath, content);
    console.log('‚úÖ ‰øÆÂ§ç‰∫Ü LoginForm ÁöÑsetStateÁ±ªÂûã');
  }
  
  // ‰øÆÂ§çRegisterForm
  const registerFormPath = path.join(__dirname, '../src/components/auth/RegisterForm.tsx');
  if (fs.existsSync(registerFormPath)) {
    let content = fs.readFileSync(registerFormPath, 'utf8');
    
    content = content.replace(
      /setFormData\(\(prev.*?\) =>/g,
      'setFormData(prev =>'
    );
    
    content = content.replace(
      /setErrors\(\(prev.*?\) =>/g,
      'setErrors(prev =>'
    );
    
    fs.writeFileSync(registerFormPath, content);
    console.log('‚úÖ ‰øÆÂ§ç‰∫Ü RegisterForm ÁöÑsetStateÁ±ªÂûã');
  }
}

/**
 * Fix 4: ‰øÆÂ§çsubscription.tierËÆøÈóÆ
 */
function fixSubscriptionTierAccess() {
  console.log('üì¶ ‰øÆÂ§çsubscription.tierËÆøÈóÆ...');
  
  const protectedRoutePath = path.join(__dirname, '../src/components/auth/ProtectedRoute.tsx');
  if (fs.existsSync(protectedRoutePath)) {
    let content = fs.readFileSync(protectedRoutePath, 'utf8');
    
    // Â∞ÜÊâÄÊúâsubscription.tierÊîπ‰∏∫subscription.plan
    content = content.replace(/subscription\.tier/g, 'subscription.plan');
    
    // Ê∑ªÂä†ÂÖºÂÆπÊÄßÊ£ÄÊü•
    content = content.replace(
      /user\.subscription\?.plan === ['"](\w+)['"]/g,
      "(user.subscription?.plan === '$1' || (user.subscription as any)?.tier === '$1')"
    );
    
    fs.writeFileSync(protectedRoutePath, content);
    console.log('‚úÖ ‰øÆÂ§ç‰∫Ü ProtectedRoute ÁöÑsubscriptionËÆøÈóÆ');
  }
}

/**
 * Fix 5: ‰øÆÂ§çCommentSection‰∏≠ÁöÑuser.id
 */
function fixCommentUserAccess() {
  console.log('üì¶ ‰øÆÂ§çCommentSectionÁöÑuserËÆøÈóÆ...');
  
  const commentPath = path.join(__dirname, '../src/components/community/CommentSection.tsx');
  if (fs.existsSync(commentPath)) {
    let content = fs.readFileSync(commentPath, 'utf8');
    
    // Á°Æ‰øùÊ≠£Á°ÆËÆøÈóÆuser id
    content = content.replace(
      /\(user\.id \|\| user\._id \|\| ''\)/g,
      "(user?.id || (user as any)?._id || '')"
    );
    
    // Ê∑ªÂä†UserÁ±ªÂûãÂØºÂÖ•
    if (!content.includes("import { User }") && !content.includes("import type { User }")) {
      content = "import type { User } from '@/shared/hooks/useAuth';\n" + content;
    }
    
    fs.writeFileSync(commentPath, content);
    console.log('‚úÖ ‰øÆÂ§ç‰∫Ü CommentSection ÁöÑuserËÆøÈóÆ');
  }
}

/**
 * Fix 6: ‰øÆÂ§çanalyticsË∑ØÁî±Á±ªÂûãÈîôËØØ
 */
function fixAnalyticsRoute() {
  console.log('üì¶ ‰øÆÂ§çanalyticsË∑ØÁî±Á±ªÂûã...');
  
  const analyticsPath = path.join(__dirname, '../src/app/api/analytics/events/route.ts');
  if (fs.existsSync(analyticsPath)) {
    let content = fs.readFileSync(analyticsPath, 'utf8');
    
    // ‰øÆÂ§çÊØîËæÉÊìç‰ΩúÁ¨¶Á±ªÂûãÈîôËØØ
    content = content.replace(
      /if\s*\(([^)]+)\s*>\s*(\d+)\)/g,
      'if (Number($1) > $2)'
    );
    
    content = content.replace(
      /else if\s*\(([^)]+)\s*>\s*(\d+)\)/g,
      'else if (Number($1) > $2)'
    );
    
    fs.writeFileSync(analyticsPath, content);
    console.log('‚úÖ ‰øÆÂ§ç‰∫Ü analytics/events Ë∑ØÁî±Á±ªÂûã');
  }
}

/**
 * Fix 7: ‰øÆÂ§çProtectedRouteÂíåLoginFormÁöÑisLoading
 */
function fixIsLoadingProperty() {
  console.log('üì¶ Ê∑ªÂä†isLoadingÂ±ûÊÄß...');
  
  // Á°Æ‰øùAuthContextTypeÂåÖÂê´isLoading
  const files = [
    'src/components/auth/ProtectedRoute.tsx',
    'src/components/auth/LoginForm.tsx',
    'src/components/auth/RegisterForm.tsx'
  ];
  
  files.forEach(file => {
    const filePath = path.join(__dirname, '..', file);
    if (fs.existsSync(filePath)) {
      let content = fs.readFileSync(filePath, 'utf8');
      
      // Ê∑ªÂä†Á±ªÂûãÂØºÂÖ•
      if (!content.includes("import type { AuthContextType }")) {
        content = content.replace(
          /import { useAuth } from ['"]@\/contexts\/AuthContext['"]/,
          "import { useAuth } from '@/contexts/AuthContext';\nimport type { AuthContextType } from '@/shared/hooks/useAuth'"
        );
      }
      
      fs.writeFileSync(filePath, content);
    }
  });
  
  console.log('‚úÖ ‰øÆÂ§ç‰∫Ü isLoading Â±ûÊÄßËÆøÈóÆ');
}

// ‰∏ªÊâßË°åÂáΩÊï∞
async function main() {
  try {
    console.log('üöÄ ÂºÄÂßã‰øÆÂ§çÊúÄÁªàTypeScriptÈîôËØØ...\n');
    
    // ÊâßË°å‰øÆÂ§ç
    ensureUseAuthExports();
    fixAuthContextImports();
    fixSetStateCallbacks();
    fixSubscriptionTierAccess();
    fixCommentUserAccess();
    fixAnalyticsRoute();
    fixIsLoadingProperty();
    
    console.log('\n‚úÖ ÊúÄÁªàTypeScriptÈîôËØØ‰øÆÂ§çÂÆåÊàêÔºÅ');
    
  } catch (error) {
    console.error('‚ùå ‰øÆÂ§çËøáÁ®ã‰∏≠Âá∫Èîô:', error.message);
    process.exit(1);
  }
}

// ËøêË°åËÑöÊú¨
main();