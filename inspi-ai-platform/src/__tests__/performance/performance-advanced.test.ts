/**
 * È´òÁ∫ßÊÄßËÉΩÊµãËØïÂ•ó‰ª∂
 * ÂåÖÂê´Ë¥üËΩΩÊµãËØï„ÄÅÂéãÂäõÊµãËØï„ÄÅÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµãÁ≠â
 */

import { test, expect } from '@playwright/test'
import { execSync } from 'child_process'
import fs from 'fs'
import path from 'path'

// ÊÄßËÉΩÊµãËØïÈÖçÁΩÆ
const PERFORMANCE_CONFIG = {
  target: process.env.TARGET_URL || 'http://localhost:3000',
  timeout: 60000,
  retries: 1,
  benchmarks: {
    pageLoad: 3000, // 3Áßí
    apiResponse: 1000, // 1Áßí
    memoryUsage: 100, // 100MB
    cpuUsage: 80, // 80%
    networkRequests: 50, // ÊúÄÂ§ß50‰∏™ËØ∑Ê±Ç
    bundleSize: 2048, // 2MB
    firstContentfulPaint: 2000, // 2Áßí
    largestContentfulPaint: 4000, // 4Áßí
    cumulativeLayoutShift: 0.1, // 0.1
    firstInputDelay: 100 // 100ms
  }
}

test.describe('È´òÁ∫ßÊÄßËÉΩÊµãËØï', () => {
  test.beforeAll(async () => {
    console.log('üöÄ ÂºÄÂßãÈ´òÁ∫ßÊÄßËÉΩÊµãËØï...')
  })

  // È°µÈù¢Âä†ËΩΩÊÄßËÉΩÊµãËØï
  test('È°µÈù¢Âä†ËΩΩÊÄßËÉΩÊµãËØï', async ({ page }) => {
    console.log('üìä ÊµãËØïÈ°µÈù¢Âä†ËΩΩÊÄßËÉΩ...')
    
    const pages = [
      '/',
      '/magic',
      '/square',
      '/knowledge-graph',
      '/profile'
    ]
    
    const results = []
    
    for (const pagePath of pages) {
      const startTime = Date.now()
      
      // ÁõëÂê¨ÊÄßËÉΩÊåáÊ†á
      const performanceMetrics = await page.evaluate(() => {
        return new Promise((resolve) => {
          new PerformanceObserver((list) => {
            const entries = list.getEntries()
            const metrics = {}
            
            entries.forEach((entry) => {
              if (entry.entryType === 'navigation') {
                metrics.domContentLoaded = entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart
                metrics.loadComplete = entry.loadEventEnd - entry.loadEventStart
                metrics.firstByte = entry.responseStart - entry.requestStart
              }
              
              if (entry.entryType === 'paint') {
                if (entry.name === 'first-contentful-paint') {
                  metrics.firstContentfulPaint = entry.startTime
                }
                if (entry.name === 'largest-contentful-paint') {
                  metrics.largestContentfulPaint = entry.startTime
                }
              }
              
              if (entry.entryType === 'layout-shift') {
                metrics.cumulativeLayoutShift = (metrics.cumulativeLayoutShift || 0) + entry.value
              }
            })
            
            resolve(metrics)
          }).observe({ entryTypes: ['navigation', 'paint', 'layout-shift'] })
          
          // Ë∂ÖÊó∂‰øùÊä§
          setTimeout(() => resolve({}), 10000)
        })
      })
      
      await page.goto(`${PERFORMANCE_CONFIG.target}${pagePath}`)
      await page.waitForLoadState('networkidle')
      
      const endTime = Date.now()
      const loadTime = endTime - startTime
      
      // Ëé∑ÂèñWeb Vitals
      const webVitals = await page.evaluate(() => {
        return new Promise((resolve) => {
          const vitals = {}
          
          // First Input Delay
          new PerformanceObserver((list) => {
            list.getEntries().forEach((entry) => {
              if (entry.entryType === 'first-input') {
                vitals.firstInputDelay = entry.processingStart - entry.startTime
              }
            })
          }).observe({ entryTypes: ['first-input'] })
          
          // Cumulative Layout Shift
          let clsValue = 0
          new PerformanceObserver((list) => {
            list.getEntries().forEach((entry) => {
              if (!entry.hadRecentInput) {
                clsValue += entry.value
              }
            })
            vitals.cumulativeLayoutShift = clsValue
          }).observe({ entryTypes: ['layout-shift'] })
          
          setTimeout(() => resolve(vitals), 5000)
        })
      })
      
      const result = {
        page: pagePath,
        loadTime,
        performanceMetrics,
        webVitals,
        passed: loadTime <= PERFORMANCE_CONFIG.benchmarks.pageLoad
      }
      
      results.push(result)
      
      console.log(`  üìÑ ${pagePath}: ${loadTime}ms ${result.passed ? '‚úÖ' : '‚ùå'}`)
      
      // È™åËØÅÊÄßËÉΩÂü∫ÂáÜ
      expect(loadTime).toBeLessThan(PERFORMANCE_CONFIG.benchmarks.pageLoad)
    }
    
    // ÁîüÊàêÊÄßËÉΩÊä•Âëä
    generatePerformanceReport('page-load', results)
  })

  // APIÂìçÂ∫îÊÄßËÉΩÊµãËØï
  test('APIÂìçÂ∫îÊÄßËÉΩÊµãËØï', async ({ page }) => {
    console.log('üîå ÊµãËØïAPIÂìçÂ∫îÊÄßËÉΩ...')
    
    const apiEndpoints = [
      { method: 'GET', url: '/api/health' },
      { method: 'GET', url: '/api/works' },
      { method: 'GET', url: '/api/works/search?q=Êï∞Â≠¶' },
      { method: 'GET', url: '/api/leaderboard' },
      { method: 'POST', url: '/api/auth/login', data: { email: 'test@example.com', password: 'password' } }
    ]
    
    const results = []
    
    for (const endpoint of apiEndpoints) {
      const startTime = Date.now()
      
      let response
      if (endpoint.method === 'GET') {
        response = await page.request.get(`${PERFORMANCE_CONFIG.target}${endpoint.url}`)
      } else if (endpoint.method === 'POST') {
        response = await page.request.post(`${PERFORMANCE_CONFIG.target}${endpoint.url}`, {
          data: endpoint.data
        })
      }
      
      const endTime = Date.now()
      const responseTime = endTime - startTime
      
      const result = {
        endpoint: `${endpoint.method} ${endpoint.url}`,
        responseTime,
        status: response.status(),
        passed: responseTime <= PERFORMANCE_CONFIG.benchmarks.apiResponse
      }
      
      results.push(result)
      
      console.log(`  üîå ${result.endpoint}: ${responseTime}ms (${result.status}) ${result.passed ? '‚úÖ' : '‚ùå'}`)
      
      // È™åËØÅÂìçÂ∫îÊó∂Èó¥Âü∫ÂáÜ
      expect(responseTime).toBeLessThan(PERFORMANCE_CONFIG.benchmarks.apiResponse)
    }
    
    generatePerformanceReport('api-response', results)
  })

  // ÂÜÖÂ≠ò‰ΩøÁî®ÊµãËØï
  test('ÂÜÖÂ≠ò‰ΩøÁî®ÊµãËØï', async ({ page }) => {
    console.log('üß† ÊµãËØïÂÜÖÂ≠ò‰ΩøÁî®...')
    
    await page.goto(`${PERFORMANCE_CONFIG.target}/`)
    
    // ÊâßË°åÂÜÖÂ≠òÂØÜÈõÜÊìç‰Ωú
    const memoryTests = [
      async () => {
        // ÊµãËØïÂ§ßÈáèDOMÊìç‰Ωú
        await page.evaluate(() => {
          for (let i = 0; i < 1000; i++) {
            const div = document.createElement('div')
            div.innerHTML = `Test content ${i}`
            document.body.appendChild(div)
          }
        })
      },
      async () => {
        // ÊµãËØïÂ§ßÈáèÊï∞ÊçÆÂ§ÑÁêÜ
        await page.evaluate(() => {
          const largeArray = new Array(100000).fill(0).map((_, i) => ({
            id: i,
            data: `Large data item ${i}`,
            timestamp: Date.now()
          }))
          
          // Ê®°ÊãüÊï∞ÊçÆÂ§ÑÁêÜ
          largeArray.forEach(item => {
            item.processed = true
            item.hash = btoa(item.data)
          })
        })
      },
      async () => {
        // ÊµãËØïÂõæÁâáÂä†ËΩΩ
        await page.evaluate(() => {
          for (let i = 0; i < 50; i++) {
            const img = new Image()
            img.src = `data:image/svg+xml;base64,${btoa(`<svg width="100" height="100"><rect width="100" height="100" fill="red"/></svg>`)}`
            document.body.appendChild(img)
          }
        })
      }
    ]
    
    const results = []
    
    for (let i = 0; i < memoryTests.length; i++) {
      const testName = `Memory Test ${i + 1}`
      
      // Ëé∑ÂèñÊµãËØïÂâçÂÜÖÂ≠ò‰ΩøÁî®
      const beforeMemory = await page.evaluate(() => {
        if (performance.memory) {
          return {
            usedJSHeapSize: performance.memory.usedJSHeapSize,
            totalJSHeapSize: performance.memory.totalJSHeapSize,
            jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
          }
        }
        return null
      })
      
      // ÊâßË°åÊµãËØï
      await memoryTests[i]()
      
      // Á≠âÂæÖÂûÉÂúæÂõûÊî∂
      await page.waitForTimeout(1000)
      
      // Ëé∑ÂèñÊµãËØïÂêéÂÜÖÂ≠ò‰ΩøÁî®
      const afterMemory = await page.evaluate(() => {
        if (performance.memory) {
          return {
            usedJSHeapSize: performance.memory.usedJSHeapSize,
            totalJSHeapSize: performance.memory.totalJSHeapSize,
            jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
          }
        }
        return null
      })
      
      if (beforeMemory && afterMemory) {
        const memoryIncrease = (afterMemory.usedJSHeapSize - beforeMemory.usedJSHeapSize) / 1024 / 1024 // MB
        const memoryUsagePercent = (afterMemory.usedJSHeapSize / afterMemory.jsHeapSizeLimit) * 100
        
        const result = {
          test: testName,
          memoryIncrease: memoryIncrease.toFixed(2),
          memoryUsagePercent: memoryUsagePercent.toFixed(2),
          beforeMemory,
          afterMemory,
          passed: memoryIncrease <= PERFORMANCE_CONFIG.benchmarks.memoryUsage
        }
        
        results.push(result)
        
        console.log(`  üß† ${testName}: +${result.memoryIncrease}MB (${result.memoryUsagePercent}%) ${result.passed ? '‚úÖ' : '‚ùå'}`)
        
        // È™åËØÅÂÜÖÂ≠ò‰ΩøÁî®Âü∫ÂáÜ
        expect(memoryIncrease).toBeLessThan(PERFORMANCE_CONFIG.benchmarks.memoryUsage)
      }
    }
    
    generatePerformanceReport('memory-usage', results)
  })

  // ÁΩëÁªúËØ∑Ê±Ç‰ºòÂåñÊµãËØï
  test('ÁΩëÁªúËØ∑Ê±Ç‰ºòÂåñÊµãËØï', async ({ page }) => {
    console.log('üåê ÊµãËØïÁΩëÁªúËØ∑Ê±Ç‰ºòÂåñ...')
    
    const requests = []
    
    // ÁõëÂê¨ÁΩëÁªúËØ∑Ê±Ç
    page.on('request', request => {
      requests.push({
        url: request.url(),
        method: request.method(),
        resourceType: request.resourceType(),
        timestamp: Date.now()
      })
    })
    
    page.on('response', response => {
      const request = requests.find(req => req.url === response.url())
      if (request) {
        request.status = response.status()
        request.size = response.headers()['content-length'] || 0
        request.responseTime = Date.now() - request.timestamp
      }
    })
    
    await page.goto(`${PERFORMANCE_CONFIG.target}/`)
    await page.waitForLoadState('networkidle')
    
    // ÂàÜÊûêËØ∑Ê±Ç
    const analysis = {
      totalRequests: requests.length,
      requestsByType: {},
      averageResponseTime: 0,
      totalSize: 0,
      slowRequests: [],
      largeRequests: []
    }
    
    requests.forEach(request => {
      // ÊåâÁ±ªÂûãÂàÜÁªÑ
      analysis.requestsByType[request.resourceType] = (analysis.requestsByType[request.resourceType] || 0) + 1
      
      // ËÆ°ÁÆóÊÄªÂ§ßÂ∞è
      analysis.totalSize += parseInt(request.size) || 0
      
      // ËØÜÂà´ÊÖ¢ËØ∑Ê±Ç
      if (request.responseTime > 2000) {
        analysis.slowRequests.push(request)
      }
      
      // ËØÜÂà´Â§ßËØ∑Ê±Ç
      if (parseInt(request.size) > 1024 * 1024) { // 1MB
        analysis.largeRequests.push(request)
      }
    })
    
    // ËÆ°ÁÆóÂπ≥ÂùáÂìçÂ∫îÊó∂Èó¥
    const totalResponseTime = requests.reduce((sum, req) => sum + (req.responseTime || 0), 0)
    analysis.averageResponseTime = totalResponseTime / requests.length
    
    console.log(`  üåê ÊÄªËØ∑Ê±ÇÊï∞: ${analysis.totalRequests}`)
    console.log(`  üåê Âπ≥ÂùáÂìçÂ∫îÊó∂Èó¥: ${analysis.averageResponseTime.toFixed(2)}ms`)
    console.log(`  üåê ÊÄªÂ§ßÂ∞è: ${(analysis.totalSize / 1024 / 1024).toFixed(2)}MB`)
    console.log(`  üåê ÊÖ¢ËØ∑Ê±ÇÊï∞: ${analysis.slowRequests.length}`)
    console.log(`  üåê Â§ßËØ∑Ê±ÇÊï∞: ${analysis.largeRequests.length}`)
    
    // È™åËØÅÁΩëÁªúËØ∑Ê±ÇÂü∫ÂáÜ
    expect(analysis.totalRequests).toBeLessThan(PERFORMANCE_CONFIG.benchmarks.networkRequests)
    expect(analysis.averageResponseTime).toBeLessThan(PERFORMANCE_CONFIG.benchmarks.apiResponse)
    
    generatePerformanceReport('network-requests', analysis)
  })

  // ËµÑÊ∫êÂåÖÂ§ßÂ∞èÊµãËØï
  test('ËµÑÊ∫êÂåÖÂ§ßÂ∞èÊµãËØï', async ({ page }) => {
    console.log('üì¶ ÊµãËØïËµÑÊ∫êÂåÖÂ§ßÂ∞è...')
    
    const resources = []
    
    page.on('response', async response => {
      const url = response.url()
      const contentType = response.headers()['content-type'] || ''
      
      if (url.includes('/_next/static/') || contentType.includes('javascript') || contentType.includes('css')) {
        try {
          const buffer = await response.body()
          resources.push({
            url,
            type: contentType.includes('javascript') ? 'js' : contentType.includes('css') ? 'css' : 'other',
            size: buffer.length,
            compressed: response.headers()['content-encoding'] === 'gzip'
          })
        } catch (error) {
          // ÂøΩÁï•Êó†Ê≥ïËé∑ÂèñbodyÁöÑÂìçÂ∫î
        }
      }
    })
    
    await page.goto(`${PERFORMANCE_CONFIG.target}/`)
    await page.waitForLoadState('networkidle')
    
    // ÂàÜÊûêËµÑÊ∫êÂåÖ
    const analysis = {
      totalSize: 0,
      jsSize: 0,
      cssSize: 0,
      otherSize: 0,
      compressedCount: 0,
      uncompressedCount: 0,
      largeFiles: []
    }
    
    resources.forEach(resource => {
      analysis.totalSize += resource.size
      
      if (resource.type === 'js') {
        analysis.jsSize += resource.size
      } else if (resource.type === 'css') {
        analysis.cssSize += resource.size
      } else {
        analysis.otherSize += resource.size
      }
      
      if (resource.compressed) {
        analysis.compressedCount++
      } else {
        analysis.uncompressedCount++
      }
      
      if (resource.size > 500 * 1024) { // 500KB
        analysis.largeFiles.push(resource)
      }
    })
    
    const totalSizeMB = analysis.totalSize / 1024 / 1024
    
    console.log(`  üì¶ ÊÄªÂåÖÂ§ßÂ∞è: ${totalSizeMB.toFixed(2)}MB`)
    console.log(`  üì¶ JSÂ§ßÂ∞è: ${(analysis.jsSize / 1024 / 1024).toFixed(2)}MB`)
    console.log(`  üì¶ CSSÂ§ßÂ∞è: ${(analysis.cssSize / 1024 / 1024).toFixed(2)}MB`)
    console.log(`  üì¶ ÂéãÁº©Êñá‰ª∂: ${analysis.compressedCount}`)
    console.log(`  üì¶ Êú™ÂéãÁº©Êñá‰ª∂: ${analysis.uncompressedCount}`)
    console.log(`  üì¶ Â§ßÊñá‰ª∂Êï∞: ${analysis.largeFiles.length}`)
    
    // È™åËØÅÂåÖÂ§ßÂ∞èÂü∫ÂáÜ
    expect(totalSizeMB).toBeLessThan(PERFORMANCE_CONFIG.benchmarks.bundleSize / 1024)
    
    generatePerformanceReport('bundle-size', analysis)
  })

  // Âπ∂ÂèëÁî®Êà∑ÊµãËØï
  test('Âπ∂ÂèëÁî®Êà∑ÊµãËØï', async ({ browser }) => {
    console.log('üë• ÊµãËØïÂπ∂ÂèëÁî®Êà∑ÊÄßËÉΩ...')
    
    const concurrentUsers = 10
    const testDuration = 30000 // 30Áßí
    const results = []
    
    const userPromises = []
    
    for (let i = 0; i < concurrentUsers; i++) {
      const userPromise = (async () => {
        const context = await browser.newContext()
        const page = await context.newPage()
        
        const userResults = {
          userId: i + 1,
          actions: [],
          errors: []
        }
        
        const startTime = Date.now()
        
        try {
          while (Date.now() - startTime < testDuration) {
            // Ê®°ÊãüÁî®Êà∑Ë°å‰∏∫
            const actions = [
              async () => {
                const actionStart = Date.now()
                await page.goto(`${PERFORMANCE_CONFIG.target}/`)
                await page.waitForLoadState('networkidle')
                userResults.actions.push({
                  action: 'visit_home',
                  duration: Date.now() - actionStart
                })
              },
              async () => {
                const actionStart = Date.now()
                await page.goto(`${PERFORMANCE_CONFIG.target}/square`)
                await page.waitForLoadState('networkidle')
                userResults.actions.push({
                  action: 'visit_square',
                  duration: Date.now() - actionStart
                })
              },
              async () => {
                const actionStart = Date.now()
                await page.goto(`${PERFORMANCE_CONFIG.target}/magic`)
                await page.waitForLoadState('networkidle')
                userResults.actions.push({
                  action: 'visit_magic',
                  duration: Date.now() - actionStart
                })
              }
            ]
            
            const randomAction = actions[Math.floor(Math.random() * actions.length)]
            await randomAction()
            
            // ÈöèÊú∫Á≠âÂæÖ
            await page.waitForTimeout(Math.random() * 2000 + 1000)
          }
        } catch (error) {
          userResults.errors.push(error.message)
        } finally {
          await context.close()
        }
        
        return userResults
      })()
      
      userPromises.push(userPromise)
    }
    
    const allResults = await Promise.all(userPromises)
    
    // ÂàÜÊûêÁªìÊûú
    const analysis = {
      totalUsers: concurrentUsers,
      totalActions: allResults.reduce((sum, user) => sum + user.actions.length, 0),
      totalErrors: allResults.reduce((sum, user) => sum + user.errors.length, 0),
      averageActionTime: 0,
      errorRate: 0
    }
    
    const allActions = allResults.flatMap(user => user.actions)
    analysis.averageActionTime = allActions.reduce((sum, action) => sum + action.duration, 0) / allActions.length
    analysis.errorRate = (analysis.totalErrors / analysis.totalActions) * 100
    
    console.log(`  üë• Âπ∂ÂèëÁî®Êà∑Êï∞: ${analysis.totalUsers}`)
    console.log(`  üë• ÊÄªÊìç‰ΩúÊï∞: ${analysis.totalActions}`)
    console.log(`  üë• ÊÄªÈîôËØØÊï∞: ${analysis.totalErrors}`)
    console.log(`  üë• Âπ≥ÂùáÊìç‰ΩúÊó∂Èó¥: ${analysis.averageActionTime.toFixed(2)}ms`)
    console.log(`  üë• ÈîôËØØÁéá: ${analysis.errorRate.toFixed(2)}%`)
    
    // È™åËØÅÂπ∂ÂèëÊÄßËÉΩ
    expect(analysis.errorRate).toBeLessThan(5) // ÈîôËØØÁéáÂ∞è‰∫é5%
    expect(analysis.averageActionTime).toBeLessThan(5000) // Âπ≥ÂùáÊìç‰ΩúÊó∂Èó¥Â∞è‰∫é5Áßí
    
    generatePerformanceReport('concurrent-users', analysis)
  })
})

// ÁîüÊàêÊÄßËÉΩÊä•Âëä
function generatePerformanceReport(testType: string, data: any) {
  const report = {
    testType,
    timestamp: new Date().toISOString(),
    data,
    benchmarks: PERFORMANCE_CONFIG.benchmarks
  }
  
  const reportPath = path.join(__dirname, `performance-${testType}-report.json`)
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2))
  
  console.log(`üìä ÊÄßËÉΩÊä•ÂëäÂ∑≤ÁîüÊàê: performance-${testType}-report.json`)
}