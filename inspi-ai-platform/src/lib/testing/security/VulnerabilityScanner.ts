/**
 * Vulnerability Scanner
 *
 * 自动化安全漏洞扫描器
 * 包括常见Web漏洞、注入攻击、配置错误等的检测
 */

export interface VulnerabilityScanConfig {
  enableWebVulnerabilityScans: boolean;
  enableInjectionScans: boolean;
  enableConfigurationScans: boolean;
  enableDependencyScans: boolean;
  scanDepth: 'shallow' | 'medium' | 'deep';
  timeout: number;
  maxConcurrentScans: number;
  customRules: ScanRule[];
  excludePatterns: string[];
}

export interface ScanRule {
  id: string;
  name: string;
  description: string;
  category: 'injection' | 'xss' | 'csrf' | 'auth' | 'config' | 'dependency' | 'custom';
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  pattern: RegExp;
  testPayload?: string;
  expectedResponse?: string;
  remediation: string;
}

export interface ScanTarget {
  type: 'url' | 'endpoint' | 'file' | 'code' | 'config';
  identifier: string;
  method?: string;
  parameters?: ScanParameter[];
  headers?: Record<string, string>;
  authentication?: AuthenticationInfo;
}

export interface ScanParameter {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'file';
  required: boolean;
  testValues: string[];
}

export interface AuthenticationInfo {
  type: 'none' | 'basic' | 'bearer' | 'cookie' | 'custom';
  credentials?: any;
}

export interface VulnerabilityScanResult {
  scanId: string;
  target: ScanTarget;
  vulnerabilities: Vulnerability[];
  scanDuration: number;
  scanStatus: 'completed' | 'failed' | 'timeout' | 'cancelled';
  scanMetadata: ScanMetadata;
  timestamp: Date;
}

export interface Vulnerability {
  id: string;
  rule: ScanRule;
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  impact: string;
  remediation: string;
  evidence: VulnerabilityEvidence;
  cvss?: CVSSScore;
  cwe?: string;
  references: string[];
}

export interface VulnerabilityEvidence {
  request?: string;
  response?: string;
  payload?: string;
  location?: string;
  context?: string;
  screenshot?: string;
}

export interface CVSSScore {
  version: string;
  vector: string;
  baseScore: number;
  temporalScore?: number;
  environmentalScore?: number;
}

export interface ScanMetadata {
  scanType: string;
  rulesApplied: number;
  requestsSent: number;
  responsesReceived: number;
  errorsEncountered: number;
  coverage: number;
}

export class VulnerabilityScanner {
  private config: VulnerabilityScanConfig;
  private defaultRules: ScanRule[];
  private activeScanCount = 0;

  constructor(config: VulnerabilityScanConfig) {
    this.config = config;
    this.defaultRules = this.generateDefaultRules();
  }

  /**
   * 运行完整的漏洞扫描
   */
  async runVulnerabilityScan(targets: ScanTarget[]): Promise<VulnerabilityScanResult[]> {
    const results: VulnerabilityScanResult[] = [];
    const scanPromises: Promise<VulnerabilityScanResult>[] = [];

    for (const target of targets) {
      if (this.activeScanCount < this.config.maxConcurrentScans) {
        const scanPromise = this.scanTarget(target);
        scanPromises.push(scanPromise);
        this.activeScanCount++;
      } else {
        // 等待一个扫描完成再继续
        await Promise.race(scanPromises);
      }
    }

    // 等待所有扫描完成
    const scanResults = await Promise.allSettled(scanPromises);

    for (const result of scanResults) {
      if (result.status === 'fulfilled') {
        results.push(result.value);
      }
    }

    return results;
  }

  /**
   * 扫描单个目标
   */
  private async scanTarget(target: ScanTarget): Promise<VulnerabilityScanResult> {
    const scanId = this.generateScanId();
    const startTime = Date.now();
    const vulnerabilities: Vulnerability[] = [];
    let scanStatus: 'completed' | 'failed' | 'timeout' | 'cancelled' = 'completed';

    try {
      const applicableRules = this.getApplicableRules(target);
      let requestsSent = 0;
      let responsesReceived = 0;
      let errorsEncountered = 0;

      // 应用扫描规则
      for (const rule of applicableRules) {
        try {
          const ruleVulnerabilities = await this.applyRule(target, rule);
          vulnerabilities.push(...ruleVulnerabilities);
          requestsSent++;
          responsesReceived++;
        } catch (error) {
          errorsEncountered++;
          console.warn(`Rule ${rule.id} failed for target ${target.identifier}:`, error);
        }

        // 检查超时
        if (Date.now() - startTime > this.config.timeout) {
          scanStatus = 'timeout';
          break;
        }
      }

      const scanDuration = Date.now() - startTime;
      const coverage = (responsesReceived / requestsSent) * 100;

      return {
        scanId,
        target,
        vulnerabilities,
        scanDuration,
        scanStatus,
        scanMetadata: {
          scanType: this.getScanType(target),
          rulesApplied: applicableRules.length,
          requestsSent,
          responsesReceived,
          errorsEncountered,
          coverage,
        },
        timestamp: new Date(),
      };
    } catch (error) {
      return {
        scanId,
        target,
        vulnerabilities,
        scanDuration: Date.now() - startTime,
        scanStatus: 'failed',
        scanMetadata: {
          scanType: this.getScanType(target),
          rulesApplied: 0,
          requestsSent: 0,
          responsesReceived: 0,
          errorsEncountered: 1,
          coverage: 0,
        },
        timestamp: new Date(),
      };
    } finally {
      this.activeScanCount--;
    }
  }

  /**
   * 应用扫描规则
   */
  private async applyRule(target: ScanTarget, rule: ScanRule): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    switch (rule.category) {
      case 'injection':
        const injectionVulns = await this.scanInjectionVulnerabilities(target, rule);
        vulnerabilities.push(...injectionVulns);
        break;
      case 'xss':
        const xssVulns = await this.scanXSSVulnerabilities(target, rule);
        vulnerabilities.push(...xssVulns);
        break;
      case 'csrf':
        const csrfVulns = await this.scanCSRFVulnerabilities(target, rule);
        vulnerabilities.push(...csrfVulns);
        break;
      case 'auth':
        const authVulns = await this.scanAuthenticationVulnerabilities(target, rule);
        vulnerabilities.push(...authVulns);
        break;
      case 'config':
        const configVulns = await this.scanConfigurationVulnerabilities(target, rule);
        vulnerabilities.push(...configVulns);
        break;
      case 'dependency':
        const depVulns = await this.scanDependencyVulnerabilities(target, rule);
        vulnerabilities.push(...depVulns);
        break;
      case 'custom':
        const customVulns = await this.scanCustomVulnerabilities(target, rule);
        vulnerabilities.push(...customVulns);
        break;
    }

    return vulnerabilities;
  }

  /**
   * 扫描注入漏洞
   */
  private async scanInjectionVulnerabilities(target: ScanTarget, rule: ScanRule): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    if (!this.config.enableInjectionScans) return vulnerabilities;

    const injectionPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM information_schema.tables --",
      '${7*7}',
      '{{7*7}}',
      "<script>alert('xss')</script>",
      '; cat /etc/passwd',
      '| whoami',
    ];

    for (const payload of injectionPayloads) {
      try {
        const response = await this.sendTestRequest(target, payload);

        if (this.detectInjectionVulnerability(response, payload, rule)) {
          vulnerabilities.push({
            id: this.generateVulnerabilityId(),
            rule,
            severity: rule.severity,
            title: `${rule.name} - Injection Vulnerability`,
            description: `Potential injection vulnerability detected using payload: ${payload}`,
            impact: this.getInjectionImpact(payload),
            remediation: rule.remediation,
            evidence: {
              request: this.formatRequest(target, payload),
              response: this.formatResponse(response),
              payload,
              location: target.identifier,
            },
            cwe: this.getCWEForInjection(payload),
            references: this.getInjectionReferences(),
          });
        }
      } catch (error) {
        // 请求失败，可能是防护措施生效
      }
    }

    return vulnerabilities;
  }

  /**
   * 扫描XSS漏洞
   */
  private async scanXSSVulnerabilities(target: ScanTarget, rule: ScanRule): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    if (!this.config.enableWebVulnerabilityScans) return vulnerabilities;

    const xssPayloads = [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert('XSS')>",
      "<svg onload=alert('XSS')>",
      "data:text/html,<script>alert('XSS')</script>",
      "'><script>alert('XSS')</script>",
      "\"><script>alert('XSS')</script>",
      "<iframe src=javascript:alert('XSS')></iframe>",
    ];

    for (const payload of xssPayloads) {
      try {
        const response = await this.sendTestRequest(target, payload);

        if (this.detectXSSVulnerability(response, payload)) {
          vulnerabilities.push({
            id: this.generateVulnerabilityId(),
            rule,
            severity: rule.severity,
            title: `${rule.name} - XSS Vulnerability`,
            description: `Cross-Site Scripting vulnerability detected using payload: ${payload}`,
            impact: 'Attackers can execute malicious scripts in user browsers',
            remediation: 'Implement proper input validation and output encoding',
            evidence: {
              request: this.formatRequest(target, payload),
              response: this.formatResponse(response),
              payload,
              location: target.identifier,
            },
            cwe: 'CWE-79',
            references: ['https://owasp.org/www-community/attacks/xss/'],
          });
        }
      } catch (error) {
        // 请求失败
      }
    }

    return vulnerabilities;
  }

  /**
   * 扫描CSRF漏洞
   */
  private async scanCSRFVulnerabilities(target: ScanTarget, rule: ScanRule): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    if (!this.config.enableWebVulnerabilityScans) return vulnerabilities;

    try {
      // 检查CSRF token
      const response = await this.sendTestRequest(target, '');

      if (!this.hasCSRFProtection(response)) {
        vulnerabilities.push({
          id: this.generateVulnerabilityId(),
          rule,
          severity: 'medium',
          title: 'Missing CSRF Protection',
          description: 'The endpoint does not implement CSRF protection',
          impact: 'Attackers can perform unauthorized actions on behalf of users',
          remediation: 'Implement CSRF tokens or SameSite cookies',
          evidence: {
            request: this.formatRequest(target, ''),
            response: this.formatResponse(response),
            location: target.identifier,
          },
          cwe: 'CWE-352',
          references: ['https://owasp.org/www-community/attacks/csrf'],
        });
      }
    } catch (error) {
      // 请求失败
    }

    return vulnerabilities;
  }

  /**
   * 扫描认证漏洞
   */
  private async scanAuthenticationVulnerabilities(target: ScanTarget, rule: ScanRule): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // 测试未授权访问
      const unauthorizedResponse = await this.sendTestRequest(target, '', { skipAuth: true });

      if (this.detectUnauthorizedAccess(unauthorizedResponse)) {
        vulnerabilities.push({
          id: this.generateVulnerabilityId(),
          rule,
          severity: 'high',
          title: 'Unauthorized Access',
          description: 'The endpoint allows unauthorized access',
          impact: 'Sensitive data or functionality may be accessible without authentication',
          remediation: 'Implement proper authentication and authorization checks',
          evidence: {
            request: this.formatRequest(target, ''),
            response: this.formatResponse(unauthorizedResponse),
            location: target.identifier,
          },
          cwe: 'CWE-862',
          references: ['https://owasp.org/www-community/Improper_Authentication'],
        });
      }

      // 测试弱认证
      const weakCredentials = [
        { username: 'admin', password: 'admin' },
        { username: 'admin', password: 'password' },
        { username: 'admin', password: '123456' },
        { username: 'test', password: 'test' },
      ];

      for (const cred of weakCredentials) {
        try {
          const response = await this.sendTestRequest(target, '', { credentials: cred });

          if (this.detectSuccessfulLogin(response)) {
            vulnerabilities.push({
              id: this.generateVulnerabilityId(),
              rule,
              severity: 'critical',
              title: 'Weak Default Credentials',
              description: `Default credentials detected: ${cred.username}/${cred.password}`,
              impact: 'System can be compromised using default credentials',
              remediation: 'Change default credentials and enforce strong password policies',
              evidence: {
                request: this.formatRequest(target, '', cred),
                response: this.formatResponse(response),
                location: target.identifier,
              },
              cwe: 'CWE-521',
              references: ['https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password'],
            });
          }
        } catch (error) {
          // 认证失败，这是预期的
        }
      }
    } catch (error) {
      // 请求失败
    }

    return vulnerabilities;
  }

  /**
   * 扫描配置漏洞
   */
  private async scanConfigurationVulnerabilities(target: ScanTarget, rule: ScanRule): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    if (!this.config.enableConfigurationScans) return vulnerabilities;

    try {
      const response = await this.sendTestRequest(target, '');

      // 检查安全头
      const securityHeaders = [
        'X-Content-Type-Options',
        'X-Frame-Options',
        'X-XSS-Protection',
        'Strict-Transport-Security',
        'Content-Security-Policy',
      ];

      for (const header of securityHeaders) {
        if (!response.headers[header.toLowerCase()]) {
          vulnerabilities.push({
            id: this.generateVulnerabilityId(),
            rule,
            severity: 'low',
            title: `Missing Security Header: ${header}`,
            description: `The response is missing the ${header} security header`,
            impact: 'Reduced protection against various attacks',
            remediation: `Add the ${header} header to responses`,
            evidence: {
              response: this.formatResponse(response),
              location: target.identifier,
            },
            references: [`https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/${header}`],
          });
        }
      }

      // 检查敏感信息泄露
      if (this.detectSensitiveInfoLeakage(response)) {
        vulnerabilities.push({
          id: this.generateVulnerabilityId(),
          rule,
          severity: 'medium',
          title: 'Sensitive Information Disclosure',
          description: 'Response contains potentially sensitive information',
          impact: 'Sensitive information may be exposed to attackers',
          remediation: 'Remove sensitive information from responses',
          evidence: {
            response: this.formatResponse(response),
            location: target.identifier,
          },
          cwe: 'CWE-200',
          references: ['https://owasp.org/www-community/Improper_Error_Handling'],
        });
      }
    } catch (error) {
      // 请求失败
    }

    return vulnerabilities;
  }

  /**
   * 扫描依赖漏洞
   */
  private async scanDependencyVulnerabilities(target: ScanTarget, rule: ScanRule): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    if (!this.config.enableDependencyScans) return vulnerabilities;

    // 这里应该集成实际的依赖扫描工具，如npm audit, snyk等
    // 目前提供模拟实现
    const knownVulnerableDependencies = [
      { name: 'lodash', version: '4.17.15', cve: 'CVE-2020-8203' },
      { name: 'express', version: '4.16.0', cve: 'CVE-2019-5413' },
      { name: 'moment', version: '2.24.0', cve: 'CVE-2017-18214' },
    ];

    for (const dep of knownVulnerableDependencies) {
      vulnerabilities.push({
        id: this.generateVulnerabilityId(),
        rule,
        severity: 'high',
        title: `Vulnerable Dependency: ${dep.name}`,
        description: `Vulnerable version of ${dep.name} (${dep.version}) detected`,
        impact: 'Application may be vulnerable to known security issues',
        remediation: `Update ${dep.name} to the latest secure version`,
        evidence: {
          location: 'package.json',
          context: `${dep.name}@${dep.version}`,
        },
        cwe: 'CWE-1104',
        references: [`https://cve.mitre.org/cgi-bin/cvename.cgi?name=${dep.cve}`],
      });
    }

    return vulnerabilities;
  }

  /**
   * 扫描自定义漏洞
   */
  private async scanCustomVulnerabilities(target: ScanTarget, rule: ScanRule): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const response = await this.sendTestRequest(target, rule.testPayload || '');

      if (rule.pattern.test(response.body)) {
        vulnerabilities.push({
          id: this.generateVulnerabilityId(),
          rule,
          severity: rule.severity,
          title: rule.name,
          description: rule.description,
          impact: 'Custom vulnerability detected',
          remediation: rule.remediation,
          evidence: {
            request: this.formatRequest(target, rule.testPayload || ''),
            response: this.formatResponse(response),
            location: target.identifier,
          },
        });
      }
    } catch (error) {
      // 请求失败
    }

    return vulnerabilities;
  }

  // 辅助方法
  private generateDefaultRules(): ScanRule[] {
    return [
      {
        id: 'sql-injection-basic',
        name: 'SQL Injection Detection',
        description: 'Detects basic SQL injection vulnerabilities',
        category: 'injection',
        severity: 'critical',
        pattern: /error in your SQL syntax|mysql_fetch_array|ORA-\d+|Microsoft OLE DB Provider/i,
        remediation: 'Use parameterized queries and input validation',
      },
      {
        id: 'xss-reflected',
        name: 'Reflected XSS Detection',
        description: 'Detects reflected cross-site scripting vulnerabilities',
        category: 'xss',
        severity: 'high',
        pattern: /<script[^>]*>.*?<\/script>/i,
        remediation: 'Implement proper input validation and output encoding',
      },
      {
        id: 'csrf-missing-token',
        name: 'Missing CSRF Protection',
        description: 'Detects missing CSRF protection',
        category: 'csrf',
        severity: 'medium',
        pattern: /^(?!.*csrf).*$/i,
        remediation: 'Implement CSRF tokens or SameSite cookies',
      },
      {
        id: 'auth-bypass',
        name: 'Authentication Bypass',
        description: 'Detects authentication bypass vulnerabilities',
        category: 'auth',
        severity: 'critical',
        pattern: /unauthorized|forbidden|access denied/i,
        remediation: 'Implement proper authentication and authorization',
      },
      {
        id: 'info-disclosure',
        name: 'Information Disclosure',
        description: 'Detects information disclosure vulnerabilities',
        category: 'config',
        severity: 'medium',
        pattern: /stack trace|debug|error|exception|warning/i,
        remediation: 'Remove sensitive information from error messages',
      },
    ];
  }

  private getApplicableRules(target: ScanTarget): ScanRule[] {
    const allRules = [...this.defaultRules, ...this.config.customRules];

    return allRules.filter(rule => {
      // 根据目标类型和扫描配置过滤规则
      if (target.type === 'url' || target.type === 'endpoint') {
        return true; // Web相关规则都适用
      }

      if (target.type === 'file' || target.type === 'code') {
        return rule.category === 'dependency' || rule.category === 'config';
      }

      return true;
    });
  }

  private async sendTestRequest(target: ScanTarget, payload: string, options: any = {}): Promise<any> {
    // 模拟HTTP请求
    // 在实际实现中，这里应该使用真实的HTTP客户端
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          status: 200,
          headers: {
            'content-type': 'text/html',
            'server': 'nginx/1.18.0',
          },
          body: `Response for ${target.identifier} with payload: ${payload}`,
        });
      }, Math.random() * 100);
    });
  }

  private detectInjectionVulnerability(response: any, payload: string, rule: ScanRule): boolean {
    return rule.pattern.test(response.body) ||
           response.body.includes(payload) ||
           response.status === 500;
  }

  private detectXSSVulnerability(response: any, payload: string): boolean {
    return response.body.includes(payload) &&
           !response.body.includes('&lt;') &&
           !response.body.includes('&gt;');
  }

  private hasCSRFProtection(response: any): boolean {
    return response.body.includes('csrf') ||
           response.headers['set-cookie']?.includes('SameSite') ||
           response.headers['x-csrf-token'];
  }

  private detectUnauthorizedAccess(response: any): boolean {
    return response.status === 200 &&
           !response.body.includes('login') &&
           !response.body.includes('unauthorized');
  }

  private detectSuccessfulLogin(response: any): boolean {
    return response.status === 200 &&
           (response.body.includes('welcome') ||
            response.body.includes('dashboard') ||
            response.headers['set-cookie']?.includes('session'));
  }

  private detectSensitiveInfoLeakage(response: any): boolean {
    const sensitivePatterns = [
      /password/i,
      /secret/i,
      /token/i,
      /api[_-]?key/i,
      /database/i,
      /connection[_-]?string/i,
      /stack trace/i,
      /debug/i,
    ];

    return sensitivePatterns.some(pattern => pattern.test(response.body));
  }

  private getScanType(target: ScanTarget): string {
    return `${target.type}_vulnerability_scan`;
  }

  private generateScanId(): string {
    return `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateVulnerabilityId(): string {
    return `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private formatRequest(target: ScanTarget, payload: string, credentials?: any): string {
    return `${target.method || 'GET'} ${target.identifier}\nPayload: ${payload}${credentials ? `\nCredentials: ${JSON.stringify(credentials)}` : ''}`;
  }

  private formatResponse(response: any): string {
    return `Status: ${response.status}\nHeaders: ${JSON.stringify(response.headers)}\nBody: ${response.body.substring(0, 500)}...`;
  }

  private getInjectionImpact(payload: string): string {
    if (payload.includes('DROP') || payload.includes('DELETE')) {
      return 'Data loss or corruption possible';
    } else if (payload.includes('UNION') || payload.includes('SELECT')) {
      return 'Unauthorized data access possible';
    } else if (payload.includes('script') || payload.includes('alert')) {
      return 'Cross-site scripting attacks possible';
    } else if (payload.includes('cat') || payload.includes('whoami')) {
      return 'System command execution possible';
    }
    return 'Security vulnerability detected';
  }

  private getCWEForInjection(payload: string): string {
    if (payload.includes('SELECT') || payload.includes('UNION')) {
      return 'CWE-89'; // SQL Injection
    } else if (payload.includes('script') || payload.includes('alert')) {
      return 'CWE-79'; // XSS
    } else if (payload.includes('cat') || payload.includes('whoami')) {
      return 'CWE-78'; // Command Injection
    } else if (payload.includes('..')) {
      return 'CWE-22'; // Path Traversal
    }
    return 'CWE-20'; // Improper Input Validation
  }

  private getInjectionReferences(): string[] {
    return [
      'https://owasp.org/www-community/Injection_Flaws',
      'https://cwe.mitre.org/data/definitions/89.html',
      'https://cwe.mitre.org/data/definitions/79.html',
      'https://cwe.mitre.org/data/definitions/78.html',
    ];
  }

  /**
   * 生成漏洞扫描报告
   */
  generateVulnerabilityReport(results: VulnerabilityScanResult[]): VulnerabilityReport {
    const totalScans = results.length;
    const completedScans = results.filter(r => r.scanStatus === 'completed').length;
    const failedScans = results.filter(r => r.scanStatus === 'failed').length;
    const timeoutScans = results.filter(r => r.scanStatus === 'timeout').length;

    const allVulnerabilities = results.flatMap(r => r.vulnerabilities);
    const totalVulnerabilities = allVulnerabilities.length;

    const severityDistribution = {
      critical: allVulnerabilities.filter(v => v.severity === 'critical').length,
      high: allVulnerabilities.filter(v => v.severity === 'high').length,
      medium: allVulnerabilities.filter(v => v.severity === 'medium').length,
      low: allVulnerabilities.filter(v => v.severity === 'low').length,
      info: allVulnerabilities.filter(v => v.severity === 'info').length,
    };

    const categoryDistribution = {
      injection: allVulnerabilities.filter(v => v.rule.category === 'injection').length,
      xss: allVulnerabilities.filter(v => v.rule.category === 'xss').length,
      csrf: allVulnerabilities.filter(v => v.rule.category === 'csrf').length,
      auth: allVulnerabilities.filter(v => v.rule.category === 'auth').length,
      config: allVulnerabilities.filter(v => v.rule.category === 'config').length,
      dependency: allVulnerabilities.filter(v => v.rule.category === 'dependency').length,
      custom: allVulnerabilities.filter(v => v.rule.category === 'custom').length,
    };

    const averageScanDuration = results.reduce((sum, r) => sum + r.scanDuration, 0) / totalScans;
    const totalRequestsSent = results.reduce((sum, r) => sum + r.scanMetadata.requestsSent, 0);
    const totalResponsesReceived = results.reduce((sum, r) => sum + r.scanMetadata.responsesReceived, 0);
    const overallCoverage = totalRequestsSent > 0 ? (totalResponsesReceived / totalRequestsSent) * 100 : 0;

    return {
      summary: {
        totalScans,
        completedScans,
        failedScans,
        timeoutScans,
        successRate: (completedScans / totalScans) * 100,
        totalVulnerabilities,
        averageScanDuration,
        overallCoverage,
      },
      severityDistribution,
      categoryDistribution,
      scanResults: results,
      topVulnerabilities: this.getTopVulnerabilities(allVulnerabilities),
      recommendations: this.generateScanRecommendations(allVulnerabilities),
      timestamp: new Date(),
    };
  }

  /**
   * 获取最严重的漏洞
   */
  private getTopVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    return vulnerabilities
      .sort((a, b) => {
        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1, info: 0 };
        return severityOrder[b.severity] - severityOrder[a.severity];
      })
      .slice(0, 10);
  }

  /**
   * 生成扫描建议
   */
  private generateScanRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = [];

    if (vulnerabilities.some(v => v.rule.category === 'injection')) {
      recommendations.push('实施严格的输入验证和参数化查询以防止注入攻击');
    }

    if (vulnerabilities.some(v => v.rule.category === 'xss')) {
      recommendations.push('实施输出编码和内容安全策略(CSP)以防止XSS攻击');
    }

    if (vulnerabilities.some(v => v.rule.category === 'csrf')) {
      recommendations.push('实施CSRF令牌和SameSite Cookie属性');
    }

    if (vulnerabilities.some(v => v.rule.category === 'auth')) {
      recommendations.push('加强身份验证和授权机制');
    }

    if (vulnerabilities.some(v => v.rule.category === 'config')) {
      recommendations.push('配置适当的安全头和错误处理');
    }

    if (vulnerabilities.some(v => v.rule.category === 'dependency')) {
      recommendations.push('定期更新依赖项并监控已知漏洞');
    }

    const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highVulns = vulnerabilities.filter(v => v.severity === 'high').length;

    if (criticalVulns > 0) {
      recommendations.push(`立即修复 ${criticalVulns} 个严重漏洞`);
    }

    if (highVulns > 0) {
      recommendations.push(`优先修复 ${highVulns} 个高危漏洞`);
    }

    if (recommendations.length === 0) {
      recommendations.push('未发现严重安全漏洞，继续保持良好的安全实践');
    }

    return recommendations;
  }
}

export interface VulnerabilityReport {
  summary: {
    totalScans: number;
    completedScans: number;
    failedScans: number;
    timeoutScans: number;
    successRate: number;
    totalVulnerabilities: number;
    averageScanDuration: number;
    overallCoverage: number;
  };
  severityDistribution: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  categoryDistribution: {
    injection: number;
    xss: number;
    csrf: number;
    auth: number;
    config: number;
    dependency: number;
    custom: number;
  };
  scanResults: VulnerabilityScanResult[];
  topVulnerabilities: Vulnerability[];
  recommendations: string[];
  timestamp: Date;
}
